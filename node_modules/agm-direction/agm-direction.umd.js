(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@agm/core')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@agm/core'], factory) :
	(factory((global['agm-direction'] = {}),global.core,global.core$1));
}(this, (function (exports,core,core$1) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AgmDirection = (function () {
    function AgmDirection(gmapsApi) {
        this.gmapsApi = gmapsApi;
        this.travelMode = 'DRIVING';
        this.transitOptions = undefined;
        this.drivingOptions = undefined;
        this.waypoints = [];
        this.optimizeWaypoints = true;
        this.provideRouteAlternatives = false;
        this.avoidHighways = false;
        this.avoidTolls = false;
        this.visible = true;
        this.infoWindow = undefined;
        this.onChange = new core.EventEmitter();
        this.sendInfoWindow = new core.EventEmitter();
        this.directionsService = undefined;
        this.directionsDisplay = undefined;
        this.isFirstChange = true;
        this.originMarker = undefined;
        this.destinationMarker = undefined;
    }
    /**
     * @return {?}
     */
    AgmDirection.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.directionDraw();
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    AgmDirection.prototype.ngOnChanges = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        /**
             * When visible is false then remove the direction layer
             */
        if (!this.visible) {
            try {
                if (typeof this.originMarker !== 'undefined') {
                    this.originMarker.setMap(null);
                    this.destinationMarker.setMap(null);
                }
                this.directionsDisplay.setPanel(null);
                this.directionsDisplay.setMap(null);
                this.directionsDisplay = undefined;
            }
            catch (/** @type {?} */ e) { }
        }
        else {
            if (this.isFirstChange) {
                this.isFirstChange = false;
                return;
            }
            /**
                   * When renderOptions are not first change then reset the display
                   */
            if (typeof obj.renderOptions !== 'undefined') {
                if (obj.renderOptions.firstChange === false) {
                    if (typeof this.originMarker !== 'undefined') {
                        this.originMarker.setMap(null);
                        this.destinationMarker.setMap(null);
                    }
                    this.directionsDisplay.setPanel(null);
                    this.directionsDisplay.setMap(null);
                    this.directionsDisplay = undefined;
                }
            }
            this.directionDraw();
        }
    };
    /**
     * This event is fired when the user creating or updating this direction
     * @return {?}
     */
    AgmDirection.prototype.directionDraw = /**
     * This event is fired when the user creating or updating this direction
     * @return {?}
     */
    function () {
        var _this = this;
        this.gmapsApi.getNativeMap().then(function (map) {
            if (typeof _this.directionsDisplay === 'undefined') {
                _this.directionsDisplay = new google.maps.DirectionsRenderer(_this.renderOptions);
                _this.directionsDisplay.setMap(map);
                _this.directionsDisplay.addListener('directions_changed', function () {
                    // #18 - listener for dragable routes
                    // #18 - listener for dragable routes
                    _this.onChange.emit(_this.directionsDisplay.getDirections());
                });
            }
            if (typeof _this.directionsService === 'undefined') {
                _this.directionsService = new google.maps.DirectionsService;
            }
            if (typeof _this.panel === 'undefined') {
                _this.directionsDisplay.setPanel(null);
            }
            else {
                _this.directionsDisplay.setPanel(_this.panel);
            }
            _this.directionsService.route({
                origin: _this.origin,
                destination: _this.destination,
                travelMode: _this.travelMode,
                transitOptions: _this.transitOptions,
                drivingOptions: _this.drivingOptions,
                waypoints: _this.waypoints,
                optimizeWaypoints: _this.optimizeWaypoints,
                provideRouteAlternatives: _this.provideRouteAlternatives,
                avoidHighways: _this.avoidHighways,
                avoidTolls: _this.avoidTolls,
            }, function (response, status) {
                if (status === 'OK') {
                    _this.directionsDisplay.setDirections(response);
                    /**
                               * Emit The DirectionsResult Object
                               * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults
                               */
                    // Custom Markers
                    if (typeof _this.markerOptions !== 'undefined') {
                        try {
                            if (typeof _this.originMarker !== 'undefined') {
                                google.maps.event.clearListeners(_this.originMarker, 'click');
                                _this.originMarker.setMap(null);
                            }
                            if (typeof _this.destinationMarker !== 'undefined') {
                                google.maps.event.clearListeners(_this.destinationMarker, 'click');
                                _this.destinationMarker.setMap(null);
                            }
                        }
                        catch (/** @type {?} */ err) {
                            console.error('Can not reset custom marker.', err);
                        }
                        var /** @type {?} */ _route = response.routes[0].legs[0];
                        try {
                            // Origin Marker
                            if (typeof _this.markerOptions.origin !== 'undefined') {
                                _this.markerOptions.origin.map = map;
                                _this.markerOptions.origin.position = _route.start_location;
                                _this.originMarker = _this.setMarker(map, _this.originMarker, _this.markerOptions.origin, _route.start_address);
                            }
                            // Destination Marker
                            if (typeof _this.markerOptions.destination !== 'undefined') {
                                _this.markerOptions.destination.map = map;
                                _this.markerOptions.destination.position = _route.end_location;
                                _this.destinationMarker = _this.setMarker(map, _this.destinationMarker, _this.markerOptions.destination, _route.end_address);
                            }
                        }
                        catch (/** @type {?} */ err) {
                            console.error('MarkerOptions error.', err);
                        }
                    }
                }
            });
        });
    };
    /**
     * Custom Origin and Destination Icon
     *
     * \@memberof AgmDirection
     * @param {?} map
     * @param {?} marker
     * @param {?} markerOpts
     * @param {?} content
     * @return {?}
     */
    AgmDirection.prototype.setMarker = /**
     * Custom Origin and Destination Icon
     *
     * \@memberof AgmDirection
     * @param {?} map
     * @param {?} marker
     * @param {?} markerOpts
     * @param {?} content
     * @return {?}
     */
    function (map, marker, markerOpts, content) {
        var _this = this;
        if (typeof this.infoWindow === 'undefined') {
            // #27 - infowindow
            this.infoWindow = new google.maps.InfoWindow({});
            this.sendInfoWindow.emit(this.infoWindow);
        }
        marker = new google.maps.Marker(markerOpts);
        marker.addListener('click', function () {
            var /** @type {?} */ infowindoContent = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;
            _this.infoWindow.setContent(infowindoContent);
            _this.infoWindow.open(map, marker);
        });
        return marker;
    };
    AgmDirection.decorators = [
        { type: core.Directive, args: [{
                    selector: 'agm-direction'
                },] },
    ];
    /** @nocollapse */
    AgmDirection.ctorParameters = function () { return [
        { type: core$1.GoogleMapsAPIWrapper, },
    ]; };
    AgmDirection.propDecorators = {
        "origin": [{ type: core.Input },],
        "destination": [{ type: core.Input },],
        "travelMode": [{ type: core.Input },],
        "transitOptions": [{ type: core.Input },],
        "drivingOptions": [{ type: core.Input },],
        "waypoints": [{ type: core.Input },],
        "optimizeWaypoints": [{ type: core.Input },],
        "provideRouteAlternatives": [{ type: core.Input },],
        "avoidHighways": [{ type: core.Input },],
        "avoidTolls": [{ type: core.Input },],
        "renderOptions": [{ type: core.Input },],
        "visible": [{ type: core.Input },],
        "panel": [{ type: core.Input },],
        "markerOptions": [{ type: core.Input },],
        "infoWindow": [{ type: core.Input },],
        "onChange": [{ type: core.Output },],
        "sendInfoWindow": [{ type: core.Output },],
    };
    return AgmDirection;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AgmDirectionModule = (function () {
    function AgmDirectionModule() {
    }
    /**
     * @return {?}
     */
    AgmDirectionModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AgmDirectionModule,
        };
    };
    AgmDirectionModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [],
                    declarations: [
                        AgmDirection,
                    ],
                    exports: [
                        AgmDirection,
                    ]
                },] },
    ];
    return AgmDirectionModule;
}());

exports.AgmDirectionModule = AgmDirectionModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
